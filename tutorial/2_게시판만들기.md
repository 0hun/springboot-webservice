# 2. SpringBoot & JPA로 간단한 게시판 만들기

이번 시간엔 SpringBoot & JPA로 간단한 게시판을 만들 예정입니다.  

> Tip)  
아직 SI 환경에선 Spring & MyBatis 를 많이 사용하지만, 쿠팡/우아한형제들/NHN Entertainment 등 자사 서비스를 개발하는 곳에선 SpringBoot & JPA를 많이 사용하고 있습니다.  
특히 기존 프로젝트 환경을 개편하시는 분들은 거의 위 스택으로 전환하려고 합니다.  
SpringBoot & JPA로 진행하시면 **진짜 집중해야할 비지니스 로직에만 집중**할수 있습니다.  
(Express, Django, Rails 못지않게 생산성이 좋습니다.)  
자사 서비스를 운영하는 회사에선 점점 더 많이 사용되고 있기 때문에 이런 회사로 가고자 하시는 분들은 이번 기회에 꼭! 시작해보셨으면 합니다.

첫번째 기능으로 간단한 게시판 CRUD를 진행하겠습니다.  
회원이나 기타 기능들을 배제하고 순수하게 게시글을 조회/등록/수정/삭제등의 기능만 작동하도록 구현하겠습니다.  
  
## 2-1. 간단 게시판 구현

src/main/java/com/jojoldu/webservice 패키지 아래에 domain 패키지를 생성합니다.

![posts1](./images/2/posts1.png)

위 그림처럼 해당 패키지 아래에 Posts 클래스와 PostsRepository 인터페이스를 생성합니다.  
  
Posts.java

```java
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@Getter
@Entity
public class Posts {

    @Id
    @GeneratedValue
    private Long id;

    @Column(length = 500, nullable = false)
    private String title;

    @Column(columnDefinition = "TEXT", nullable = false)
    private String content;

    private String author;
    private LocalDateTime createdTime;
    private LocalDateTime updatedTime;

    @Builder
    public Posts(String title, String content, String author, LocalDateTime createdTime, LocalDateTime updatedTime) {
        this.title = title;
        this.content = content;
        this.author = author;
        this.createdTime = createdTime;
        this.updatedTime = updatedTime;
    }
}
```
여기서 Posts 클래스는 실제 DB의 테이블과 매칭될 클래스이며 보통 **Entity클래스**라고도 합니다.  
JPA를 사용하시면 DB 데이터에 작업할 경우 실제 쿼리를 날리기 보다는, 이 Entity 클래스의 수정을 통해 작업합니다.  
  
Posts 클래스에는 JPA에서 제공하는 어노테이션들이 몇개 있습니다.  

* ```@Entity``` 
  * 테이블과 링크될 클래스임을 나타냅니다.
  * 언더스코어 네이밍(```_```)으로 이름을 매칭합니다.
    * ex) SalesManager.java -> sales_manager table
* ```@Id```
  * 해당 테이블의 PK 필드를 나타냅니다.
* ```@GeneratedValue```
  * PK의 생성 규칙을 나타냅니다.
  * 기본값은 AUTO 로, MySQL의 auto_increment와 같이 자동증가하는 정수형 값이 됩니다.
* ```@Column```
  * 테이블의 컬럼을 나타내면, 굳이 선언하지 않더라도 해당 클래스의 필드는 모두 컬럼이 됩니다.
  * 사용하는 이유는, 기본값 외에 추가로 변경이 필요한 옵션이 있을경우 사용합니다.
  * 문자열의 경우 VARCHAR(255)가 기본값인데, 사이즈를 500으로 늘리고 싶거나(ex: ```title```), 타입을 TEXT로 변경하고 싶거나(ex: ```content```) 등의 경우에 사용됩니다.

> Tip)  
웬만하면 Entity의 PK는 Long 타입의 Auto_increment를 선택하세요.  
(MySQL 기준으로 이렇게 하면 bigint 타입이 됩니다.)  
주민등록번호와 같은 비지니스상 유니크키나, 여러키를 조합한 복합키로 PK를 잡을 경우 난감한 상황이 종종 발생합니다.  
(1) FK를 맺을때 다른 테이블에서 복합키 전부를 갖고 있거나, 중간 테이블을 하나더 둬야하는 상황이 발생합니다.  
(2) 인덱스에 좋은 영향을 끼치지 못합니다.  
(3) 유니크한 조건이 변경될 경우 PK 전체를 수정해야하는 일이 발생합니다.  
주민등록번호, 복합키 등은 유니크키로 별도로 추가하시는것을 추천드립니다.   

위에서 소개드린 어노테이션 외에 몇개의 어노테이션들이 더 보입니다.  
(```@NoArgsConstructor```, ```@Getter```, ```@Builder```)  
  
이는 처음 프로젝트 생성시 추가했던 **Lombok 라이브러리의 어노테이션**들입니다.  
어노테이션 이름만 봐도 대략 기능을 예측할수 있습니다.  

* ```@NoArgsConstructor``` : 기본 생성자 자동 추가
  * ```access = AccessLevel.PROTECTED``` : 기본생성자의 접근 권한을 protected로 제한
    * ```protected Posts() {}```
  * Entity 클래스를 **코드상에서 기본생성자로 생성하는 것은 막되**, **JPA에서 Entity 클래스를 생성하는것은 허용**하기 위해 추가 (권장사항)
* ```@Getter``` : 클래스내 모든 필드의 Getter 메소드를 자동생성
* ```@Builder``` : 해당 클래스의 빌더패턴 클래스를 생성
  * 생성자 상단에 선언시 생성자에 포함된 필드만 빌더에 포함

특히 서비스 구축단계에선 테이블 설계(여기선 Entity설계)가 빈번하게 변경되는데, 이때 Lombok의 어노테이션들은 코드 변경량을 최소화시켜주기 때문에 아주 **강력 추천**하는 라이브러리입니다.  
  
> Tip)  
Lombok은 의존성만 추가해선 IDE에서 바로 사용할수가 없기 때문에 각 IDE 환경에 맞게 Lombok 사용환경 구성이 필요합니다.  
(1) [Eclipse Lombok 설치](http://countryxide.tistory.com/16)  
(2) [IntelliJ Lombok 설치](http://blog.woniper.net/229)  
Lombok은 장점이 굉장히 많은 도구이지만, 조심해야할 부분들이 몇가지 있습니다.  
손권남님께서 정리하신 [Lombok 주의사항](http://kwonnam.pe.kr/wiki/java/lombok/pitfall)을 꼭 참고하시길 바랍니다.  
만약 이것들이 다 귀찮으시다면 직접 Getter와 생성자를 생성하셔도 무방합니다.  
다만 앞으로의 **모든 코드는 Lombok를 사용한것을 가정**하고 진행하기 때문에 코드가 조금 다를수 있다는점 유의바랍니다.  
  
Entity 클래스를 생성하실때, 주의하실것은 **무분별한 setter 메소드 생성**입니다.  
자바빈 규약을 생각하시면서 getter/setter를 무작정 생성하시는 분들이 계시는데요.  
이렇게 되면 해당 클래스의 인스턴스 값들이 **언제 어디서 변해야하는지 코드상으로 명확히 구분할수가 없어, 차후 기능변경시 정말 복잡**해집니다.  
해당 필드의 값 변경이 필요하면 **명확히 그 목적과 의도를 나타낼 수 있는 메소드**를 추가하셔야만 합니다.  
  
ex) 주문취소

```java

잘못된 사용
public void setStatus(boolean status){
    this.status = status
}

public void 주문서비스의_취소메소드 (){
   order.setStatus(false);
}

올바른 사용
public void cancelOrder(){
    this.status = false;
}

public void 주문서비스의_취소메소드 (){
   order.cancelOrder();
}
```

자 그러면 여기서 한가지 궁금한 점이 생길 수 있는데요.  
기본생성자도 ```AccessLevel.PROTECTED```로 막아놓고, **setter 메소드도 없는 이 상황에서 어떻게 값을 채워 DB에 insert 해야할까요?**  
이때를 위해 ```@Builder```를 사용합니다.  

> Tip  
빌더 패턴에 대한 소개와 예제는 [링크](http://using.tistory.com/71)를 참고하시면 좋습니다.  
  
 ```@Builder```를 통해 제공되는 빌더 클래스를 통해 값을 채워 인스턴스를 생성하고 등록합니다.  
이 부분은 실제로 코드로 보면 더 좋을것 같아 빠르게 다른 부분도 생성하겠습니다.  
  
PostsRepository.java

```java
public interface PostsRepository extends JpaRepository<Posts, Long>{
}
```

보통 ibatis/MyBatis 등에서 Dao라고 불리는 DB Layer 접근자입니다.  
JPA에선 Repository라고 부르며 인터페이스로 생성합니다.  
단순히 인터페이스를 생성후, ```JpaRepository<Entity클래스, PK타입>```를 상속하면 기본적인 CRUD가 자동생성 됩니다.  
특별히 ```@Repository```를 추가할 필요도 없습니다.  
  
자 그럼 잘 작동되는지 한번 테스트 해보겠습니다.  
간단하게 테스트 코드로 검증해보겠습니다.  
이번엔 src/**test**/java/com/jojoldu/webservice/domain 패키지에 PostsRepositoryTest 클래스를 생성하겠습니다.

```java
import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertThat;

@RunWith(SpringRunner.class)
@SpringBootTest
public class PostsRepositoryTest {

    @Autowired
    PostsRepository postsRepository;

    @After
    public void cleanup() {
        postsRepository.deleteAll();
    }

    @Test
    public void 게시글저장_불러오기() {
        //given
        final LocalDateTime createdTime = LocalDateTime.of(2017, 12, 24, 14, 0);
        final LocalDateTime updatedTime = LocalDateTime.of(2017, 12, 25, 14, 0);
        postsRepository.save(Posts.builder()
                .title("테스트 게시글")
                .content("테스트 본문")
                .author("jojoldu@gmail.com")
                .createdTime(createdTime)
                .updatedTime(updatedTime)
                .build());

        //when
        List<Posts> postsList = postsRepository.findAll();

        //then
        Posts posts = postsList.get(0);
        assertThat(posts.getTitle(), is("테스트 게시글"));
        assertThat(posts.getContent(), is("테스트 본문"));
        assertThat(posts.getCreatedTime(), is(createdTime));
    }
}
```

위 코드는 Junit 이란 테스트 프레임워크로 작성된 코드에 **어떤 값을 입력할 경우 어떤 결과가 반환되는지 검증**할수 있습니다.  



> Tip)  
실제로 데이터의 조회는 FK의 조인, 복잡한 조건등으로 인해 이런 Entity 클래스만으로 처리하기 어려워 조회용 프레임워크를 추가로 사용합니다.  
대표적 예로 querydsl, jooq, MyBatis 등이 있습니다.  
조회는 위 3가지 프레임워크중 하나를 통해 조회하고, 등록/수정/삭제 등은 SpringDataJpa를 통해 진행합니다.  
(개인적으로는 querydsl를 강추합니다.)  
JPA, querydsl에 대한 더 자세한 내용은 [김영한님의 자바 ORM 표준 JPA 프로그래밍](http://www.yes24.com/24/goods/19040233) 을 참고하시면 됩니다


> Tip)  
JSP, Freemarker, Velocity가 몇년동안 업데이트가 안되고 있어 사실상 SpringBoot에선 권장하지 않는 템플릿엔진입니다.  
현재까지도 꾸준하게 업데이트 되고 있는 템플릿 엔진은 Thymeleaf, Handlebars 이며 이 중 하나를 선택하시면 됩니다.  
개인적으로는 Handlebars를 추천합니다.  
(1) 문법이 다른 템플릿엔진보다 간단하고  
(2) 로직 코드를 사용할 수 없어 View의 역할과 서버의 역할을 시스템상으로 명확하게 제한할 수 있으며  
(3) Handlebars.js와 Handlebars.java 2가지가 다 있어, 하나의 문법으로 클라이언트 템플릿/서버 템플릿을 모두 적용해볼 수 있습니다.  
개인적으로 View 템플릿엔진은 View의 역할에만 충실하면 된다고 생각합니다.  
너무 많은 기능을 제공하면 API와 View템플릿엔진, JS가 서로 로직을 나눠갖게 되어 유지보수하기가 굉장히 어렵습니다.  
이런 점에서 제가 

