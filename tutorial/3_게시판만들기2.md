# 3. SpringBoot & Handlebars로 화면 만들기 

이번 시간엔 SpringBoot & Handlebars로 간단한 화면을 만들 예정입니다.  
Handlebars는 흔히 사용하시는 Freemarker, Velocity와 같은 서버 템플릿 엔진입니다.  
JSP는 서버 템플릿 역할만 하지 않기 때문에 JSP와 완전히 똑같은 역할을 한다고 볼순 없지만, 순수하게 **JSP를 View 용으로만 사용하실때는 똑같은 역할**이라고 보시면 됩니다.  
  
결국 URL 요청시, 파라미터와 상태에 맞춰 적절한 HTML 화면을 생성해 전달하는 역할을 하는것으로 보시면 됩니다.

> Tip)  
JSP, Freemarker, Velocity가 몇년동안 업데이트가 안되고 있어 사실상 SpringBoot에선 권장하지 않는 템플릿엔진입니다.  
(Freemarker는 프리뷰버전은 계속나오고 있는데 릴리즈버전이 2015년이 마지막입니다.)  
현재까지도 꾸준하게 업데이트 되고 있는 템플릿 엔진은 Thymeleaf, Handlebars 이며 이 중 하나를 선택하시면 됩니다.  
개인적으로는 Handlebars를 추천합니다.  
(Spring 진영에선 Thymeleaf를 밀고 있습니다.)  
(1) 문법이 다른 템플릿엔진보다 간단하고  
(2) 로직 코드를 사용할 수 없어 **View의 역할과 서버의 역할을 명확하게 제한**할 수 있으며  
(3) Handlebars.js와 Handlebars.java 2가지가 다 있어, 하나의 문법으로 클라이언트 템플릿/서버 템플릿을 모두 사용할 수 있습니다.  
개인적으로 **View 템플릿엔진은 View의 역할에만 충실**하면 된다고 생각합니다.  
너무 많은 기능을 제공하면 API와 View템플릿엔진, JS가 서로 로직을 나눠갖게 되어 유지보수하기가 굉장히 어렵습니다. 

## 3-1. Handlebars 연동

Handlebars는 아직 정식 SpringBoot starter 패키지가 존재하진 않지만, 많은 분들이 사용중이신 라이브러리인 [handlebars-spring-boot-starter](https://github.com/allegro/handlebars-spring-boot-starter)가 있어 이를 사용할 예정입니다.  
(정식 패키지에 포함시켜도 될텐데 SpringBoot에서 왜 안넣는지가 궁금하긴 하네요.)  
  
### 의존성 추가

build.gradle에 다음과 같이 의존성을 추가합니다.

![handlebar1](./images/3/handlebar1.png)

```groovy
compile 'pl.allegro.tech.boot:handlebars-spring-boot-starter:0.2.15'
```

의존성 하나만 추가하면 기존에 다른 스타터 패키지와 마찬가지로 추가 설정없이 설치가 끝입니다.  
다른 서버 템플릿 스타터 패키지와 마찬가지로 Handlebars도 기본 경로는 src/main/resources/templates가 됩니다.  
  
> Tip)  
스프링부트는 디폴트 설정이 굉장히 많습니다.  
기존의 스프링처럼 개인이 **하나하나 설정 코드를 다 작성할 필요가 없습니다**.  
스프링부트를 쓰면 많은 설정을 생략할 수 있습니다.  
영상을 참고하셔서 이런 점들은 숙지하시면 좋을것 같습니다.  
[권용근 - 스프링부트를 대하는 자세](https://www.youtube.com/watch?v=52i6gHnS1_g)

> Tip)  
혹시 IntelliJ를 사용중이시라면 아래와 같이 Handlebars 플러그인을 설치하면 문법체크 등과 같이 많은 지원을 받을 수 있습니다.

![handlebar2](./images/3/handlebar2.png)

### 메인 페이지 생성

실제로 사용할 Handlebars 파일을 생성하겠습니다.   src/main/resources/templates에 **main.hbs** 파일을 생성합니다.

```html
<!DOCTYPE HTML>
<html>
<head>
    <title>스프링부트 웹서비스</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

</head>
<body>
    <h1>스프링부트로 시작하는 웹 서비스</h1>
</body>
</html>
```

메인페이지가 생성되었으니, URL요청시 main.hbs 파일을 호출할수 있도록 Controller을 만들겠습니다.  
web패키지 안에 webController를 만들겠습니다.  

```java
@Controller
@AllArgsConstructor
public class WebController {

    @GetMapping("/")
    public String main() {
        return "main";
    }
}
```

Spring 4.3 부터는 ```@RequestMapping```을 대체할 수 있는 여러 매핑 어노테이션이 추가 되었습니다.  
위에서 나온 ```@GetMapping```은 이전으로 보면 ```@RequestMapping(value="/", method = RequestMethod.GET)```과 동일합니다.  
  
handlebars-spring-boot-starter 덕분에 컨트롤러에서 문자열을 반환할때 앞의 path와 뒤의 파일 확장자는 자동으로 지정됩니다.  
(prefix: src/main/resources/templates, suffix: .hbs)  
즉 여기선 ```"main"```을 반환하니, src/main/resources/templates/main.hbs로 전환되어 View Resolver가 처리하게 됩니다.  
(ViewResolver는 URL 요청의 결과를 전달할 타입과 값을 지정하는 관리자 격으로 보시면 됩니다.)  
  
자 여기까지 코드가 완성되었으니, 잘 되는지 확인해봐야 합니다.  
이전 포스팅과 마찬가지로 이번에도 테스트 코드로 검증해보겠습니다.

### 메인 페이지 테스트 코드

src/**test**/java/com/jojoldu/webservice/web에 WebControllerTest 클래스를 생성하겠습니다.

```java
import static org.assertj.core.api.Assertions.assertThat;
import static org.springframework.boot.test.context.SpringBootTest.WebEnvironment.RANDOM_PORT;

@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = RANDOM_PORT)
public class WebControllerTest {

    @Autowired
    private TestRestTemplate restTemplate;

    @Test
    public void 메인페이지_로딩() {
        //when
        String body = this.restTemplate.getForObject("/", String.class);

        //then
        assertThat(body).contains("스프링부트로 시작하는 웹 서비스");
    }
}
```

이번 테스트는 실제로 URL 호출시 제대로 페이지가 호출되는지에 대한 테스트입니다.  
HTML도 결국은 규칙이 있는 문자열입니다.  
TestRestTemplate를 통해 "/"로 호출했을때 **main.hbs에 포함된 코드들이 있는지 확인**하면 됩니다.  
  
전체 코드를 다 찾을 필요는 없으니, ```"스프링부트로 시작하는 웹 서비스"```문자열이 포함되어 있는지만 비교하겠습니다.  
  
![handlebar3](./images/3/handlebar3.png)

오! 테스트가 통과됐습니다.  
그럼 실제로 화면이 잘 나오는지 한번 보겠습니다.  
Application의 메인메소드를 실행하고 localhost:8080 으로 접속해보겠습니다.

![handlebar4](./images/3/handlebar4.png)

짠 정상적으로 화면이 노출되는게 확인 됩니다!  
기본적인 화면 생성이 완성되었으니, 좀더 다양한 주제로 가겠습니다.

## 3-2. 게시글 등록 + 리스트 출력

이번에는 화면에서 게시글 등록 기능을 구현해보겠습니다.  

### service 메소드 구현

지금부터는 Service 메소드도 생성해서 트랜잭션까지 관리하겠습니다.  
  
src/main/java/com/jojoldu/webservice/ 아래에 service 패키지를 생성후, PostsService 클래스를 생성하겠습니다.

```java
@AllArgsConstructor
@Service
public class PostsService {
    private PostsRepository postsRepository;

    @Transactional
    public void save(PostsSaveRequestDto dto){
        postsRepository.save(dto.toEntity());
    }
}
```

Service 메소드는 Entity를 바로 받지 않고, [이전 포스팅](http://jojoldu.tistory.com/251) 에서 생성한 Save용 DTO인 PostsSaveRequestDto를 받아서 저장합니다.  

> Tip)  
Controller에서 Dto.toEntity를 통해서 바로 전달해도 되는데 굳이 Service에서 Dto를 받는 이유는 간단합니다.  
**Controller와 Service 의 역활을 분리**하기 위함입니다.  
비지니스 로직 & 트랜잭션 관리는 모두 Service에서 관리하고, View 와 연동되는 부분은 Controller에서 담당하도록 구성합니다.
  
> Tip) 트랜잭션?  
일반적으로 DB 데이터를 등록/수정/삭제 하는 Service 메소드는 ```@Transactional```를 필수적으로 가져갑니다.  
이 어노테이션이 하는 일은 간단합니다.  
메소드 내에서 Exception이 발생하면 해당 메소드에서 이루어진 모든 DB작업을 초기화 시킵니다.  
즉, save 메소드를 통해서 10개를 등록해야하는데 5번째에서 Exception이 발생하면 앞에 저장된 4개까지를 전부 롤백시켜버립니다.  
(정확히 얘기하면, **이미 넣은걸 롤백시키는건 아니며**, **모든 처리가 정상적으로 됐을때만 DB에 커밋**하며 그렇지 않은 경우엔 커밋하지 않는것입니다.)  
좀 더 상세한 설명이 필요하신 분들은 [트랜잭션이란 도대체 뭐란 말인가!](http://springmvc.egloos.com/495798)를 참고하세요!


Service 메소드가 생성되었으니, 잘 작동되는지 간단한 테스트 코드를 추가하겠습니다.  
src/**test**/java/com/jojoldu/webservice/service 패키지를 생성후, PostServiceTest 클래스를 생성합니다.  


```java
import static org.assertj.core.api.Assertions.assertThat;

@RunWith(SpringRunner.class)
@SpringBootTest
public class PostServiceTest {

    @Autowired
    private PostsService postsService;

    @Autowired
    private PostsRepository postsRepository;

    @After
    public void cleanup () {
        postsRepository.deleteAll();
    }

    @Test
    public void Dto데이터가_posts테이블에_저장된다 () {
        //given
        PostsSaveRequestDto dto = PostsSaveRequestDto.builder()
                .author("jojoldu@gmail.com")
                .content("테스트")
                .title("테스트 타이틀")
                .build();

        //when
        postsService.save(dto);

        //then
        Posts posts = postsRepository.findAll().get(0);
        assertThat(posts.getAuthor()).isEqualTo(dto.getAuthor());
        assertThat(posts.getContent()).isEqualTo(dto.getContent());
        assertThat(posts.getTitle()).isEqualTo(dto.getTitle());
    }
}

```

테스트 코드가 하는 내용은 간단합니다.  
Dto 클래스가 service.save 메소드에 전달되면, DB에 잘 저장되었는지 검증하는 것입니다.  
  
위 테스트 코드를 돌리실려면 PostsSaveRequestDto에 Builder 가 필요합니다.  
PostsSaveRequestDto에 Builder도 추가하겠습니다.

```java
...
public class PostsSaveRequestDto {

    private String title;

    ....

    @Builder
    public PostsSaveRequestDto(String title, String content, String author) {
        this.title = title;
        this.content = content;
        this.author = author;
    }

    public Posts toEntity(){
        ...
    }
}
```

자 그럼 테스트 코드를 실행해보겠습니다.

![handlebar5](./images/3/handlebar5.png)

테스트 코드가 잘 통과했음을 알 수 있습니다.  
그럼 WebRestController의 save 메소드를 service의 save로 교체하겠습니다.

```java

@RestController
@AllArgsConstructor
public class WebRestController {

    private PostsService postsService;

    ...

    @PostMapping("/posts")
    public void savePosts(@RequestBody PostsSaveRequestDto dto){
        postsService.save(dto);
    }
}
```

여기까지 하시면 Java 코드는 완성된 것입니다.  
Handlebars로 입력 화면을 생성해보겠습니다.

### 입력화면

백엔드 개발자가 CSS를 전부 구성하기엔 무리가 있습니다.  
그래서 오픈소스인 [부트스트랩](https://getbootstrap.com/)을 활용하겠습니다.  

> Tip)  
화면을 만드는 상세한 부분은 [인프런](https://www.inflearn.com/), [코드스쿼드](http://codesquad.kr/page/masters.html) 등을 통해서 습득 하시면 될것 같습니다.  
  
부트스트랩, jQuery 등 프론트엔드 라이브러리를 사용할 수 있는 방법은 크게 2가지가 있습니다.  
하나는 외부 CDN을 사용하는 것이고, 다른 하나는 직접 라이브러리를 받아서 사용하는 방법입니다.  
(npm/bower + grunt/gulp/webpack 등을 통한 방법도 후자에 속한다고 보시면 됩니다.)  
  
CDN을 통한 방법이란 아래와 같이

![handlebar6](./images/3/handlebar6.png)

외부 서버를 통해 라이브러리를 받는 방식을 얘기합니다.  
본인의 프로젝트에서 직접 다운받아 사용할 필요도 없고, 사용방법도 HTML/JSP/Handlebars에 코드만 한줄 추가하면 되니 굉장히 간단합니다.  
하지만 이 방법을 실제 서비스에서는 잘 사용하지 않습니다.  
결국은 외부 서비스에 우리 서비스가 의존하게 되버려서, **CDN을 서비스하는 곳에 문제가 생기면 덩달아 같이 문제**가 생기기 때문입니다.  
  
자 그래서 저희가 사용할 2개의 프론트엔드 라이브러리를 다운받겠습니다. 

* [bootstrap](https://getbootstrap.com/)
  * 우측 상단의 Download를 클릭해 4.0 버전을 받습니다.
  * dist 폴더 아래에 있는 css폴더에서 bootstrap.min.css를 src/main/resources/static/**css/lib**로 복사합니다.
  * 마찬가지로 dist 폴더 아래에 있는 bootstrap.min.js를 src/main/resources/static/**js/lib**로 복사합니다.
   
![handlebar7](./images/3/handlebar7.png)

(bootstrap의 압축을 풀고 나온 dist 폴더에서 css 아래의 )
* [jQuery](https://jquery.com/download/)
  * ```Download the compressed, production jQuery 3.2.1``` 을 클릭해 다운받습니다.
  * jquery-3.2.1.min.js -> jquery.min.js 로 이름을 변경
  * src/main/resources/static/**js/lib** 로 복사합니다.

> Tip)  
프론트엔드의 이런 의존성관리, scope관리 등등의 문제들 때문에 최근에 JS 개발환경이 급변했습니다.  
Angular, React등은 아니지만, 모던한 개발환경을 경험해보고 싶으신 분들이라면 이전에 포스팅한 [시리즈](http://jojoldu.tistory.com/44)를 참고하시면 도움 되실것 같습니다.






> Tip)  
실제로 데이터의 조회는 FK의 조인, 복잡한 조건등으로 인해 이런 Entity 클래스만으로 처리하기 어려워 조회용 프레임워크를 추가로 사용합니다.  
대표적 예로 querydsl, jooq, MyBatis 등이 있습니다.  
조회는 위 3가지 프레임워크중 하나를 통해 조회하고, 등록/수정/삭제 등은 SpringDataJpa를 통해 진행합니다.  
(개인적으로는 querydsl를 강추합니다.)  
JPA, querydsl에 대한 더 자세한 내용은 [김영한님의 자바 ORM 표준 JPA 프로그래밍](http://www.yes24.com/24/goods/19040233) 을 참고하시면 아주 좋습니다.


